/*!
 *
 *      Module for converting from XML to DOM representation
 *
 */

use std::borrow::Borrow;

use xml::{attribute::OwnedAttribute, reader::XmlEvent, EventReader};

use crate::{
    dom::{node::Node, tree::NodeTree},
    tree::{unaware_tree::UnawareTree, BasicTree},
};

use super::super::node::Element;

pub struct DomFromXml<'a> {
    reader: EventReader<&'a [u8]>,
}

fn attribute_to_key_value(attr: &OwnedAttribute) -> (String, String) {
    (attr.name.to_string(), attr.value.to_string())
}

impl<'a> DomFromXml<'a> {
    /**
     * Creates a new XML to DOM parser from parser-lived str
     */
    pub fn from_str(string: &'a str) -> Self {
        Self {
            reader: EventReader::new(string.as_bytes()),
        }
    }

    /**
     * Parses the string provided and returns any BasicTree
     * Accepts self thus destructs it after the parser is complete
     */
    pub fn parse<Tree: BasicTree<Node>>(mut self) -> Result<NodeTree<Tree>, xml::reader::Error> {
        Ok(NodeTree::from_tree_vec(self.parse_nodes()?))
    }

    fn parse_nodes<Tree: BasicTree<Node>>(&mut self) -> Result<Vec<Tree>, xml::reader::Error> {
        let mut nodes = vec![];

        /*
         * Loop will be exited when we reach end of the element
         */
        loop {
            match self.reader.next() {
                Ok(XmlEvent::StartElement {
                    name, attributes, ..
                }) => {
                    /*
                     * Create element
                     */
                    let el = Element::new(
                        name.to_string(),
                        attributes.iter().map(attribute_to_key_value).collect(),
                    );

                    /*
                     * Attach it
                     */
                    nodes.push({
                        let mut subtree = Tree::new_node(Node::Element(el));

                        /*
                         * Add children to the element
                         */
                        subtree.with_children(self.parse_nodes()?);
                        subtree
                    })
                }
                /*
                 * Break out
                 */
                Ok(XmlEvent::EndElement { .. }) | Ok(XmlEvent::EndDocument) => return Ok(nodes),

                /*
                 * This will parse text nodes
                 */
                Ok(XmlEvent::Characters(text)) => {
                    nodes.push(Tree::new_leaf(Node::Text(text)));
                }
                Err(e) => return Err(e),
                _ => {}
            }
        }
    }
}

/*
 * Just for convenience we will have an idiomatic conversion from &'a str
 */
impl<'a> From<&'a str> for DomFromXml<'a> {
    fn from(string: &'a str) -> Self {
        Self::from_str(string)
    }
}

/**
 * Basic valid input without text nodes
 */
const INPUT_BASIC_VALID: &'static str = r#"
<?xml version="1.0" encoding="utf-8"?>
<root>
</root>
"#;

/**
 * Invalid input with too many roots
 */
const INPUT_TOO_MANY_ROOTS: &'static str = r#"
<?xml version="1.0" encoding="utf-8"?>
<root>
</root>
<root>
</root>
"#;

/**
 * Invalid input with no roots
 */
const INPUT_NO_ROOTS: &'static str = r#"
<?xml version="1.0" encoding="utf-8"?>
"#;

/**
 * Invalid input with only text root
 */
const INPUT_TEXT_ROOT: &'static str = r#"
<?xml version="1.0" encoding="utf-8"?>
Hello!!
"#;

/**
 * Valid input with text inside root element
 */
const INPUT_ROOT_WITH_TEXT: &'static str = r#"
<?xml version="1.0" encoding="utf-8"?>
<Super>Mario</Super>
"#;

/**
 * Valid input with mixed nodes inside root element
 */
const INPUT_ROOT_WITH_SUB_ELEMENT: &'static str = r#"
<?xml version="1.0" encoding="utf-8"?>
<Span><Bold>Super</Bold>Mario Bros</Span>
"#;

#[test]
fn test_basic_conversion() {
    let parsed = DomFromXml::from(INPUT_BASIC_VALID)
        .parse::<UnawareTree<Node>>()
        .unwrap();
    let root_node = parsed.tree.node.as_element().unwrap();
    assert_eq!(root_node.tag_name, "root");
}

#[test]
#[should_panic(expected = "more than one")]
fn test_contains_too_many() {
    DomFromXml::from(INPUT_TOO_MANY_ROOTS)
        .parse::<UnawareTree<Node>>()
        .unwrap();
}

#[test]
#[should_panic(expected = "no root")]
/**
 * This will react to error provided by `xml_parser` crate, not the panic generated by `NodeTree`
 */
fn test_contains_nothing() {
    DomFromXml::from(INPUT_NO_ROOTS)
        .parse::<UnawareTree<Node>>()
        .unwrap();
}

#[test]
#[should_panic(expected = "characters outside")]
fn test_contains_text_as_root() {
    DomFromXml::from(INPUT_TEXT_ROOT)
        .parse::<UnawareTree<Node>>()
        .unwrap();
}

#[test]
fn test_root_contains_text() {
    let parsed = DomFromXml::from(INPUT_ROOT_WITH_TEXT)
        .parse::<UnawareTree<Node>>()
        .unwrap();
    {
        let root_node = parsed.tree.node.as_element().unwrap();
        assert_eq!(root_node.tag_name.as_str(), "Super");
    }
    assert_eq!(
        parsed
            .tree
            .borrow()
            .get_child_node(0)
            .unwrap()
            .as_text()
            .unwrap(),
        "Mario"
    );
}

#[test]
fn test_root_contains_sub_element() {
    let parsed = DomFromXml::from(INPUT_ROOT_WITH_SUB_ELEMENT)
        .parse::<UnawareTree<Node>>()
        .unwrap();
    let root_node = parsed.tree;
    assert_eq!(
        root_node.node.as_element().unwrap().tag_name.as_str(),
        "Span"
    );
    assert_eq!(
        root_node
            .get_child_node(0)
            .unwrap()
            .as_element()
            .unwrap()
            .tag_name
            .as_str(),
        "Bold"
    );
    assert_eq!(
        root_node
            .get_child(0)
            .unwrap()
            .get_child_node(0)
            .unwrap()
            .as_text()
            .unwrap(),
        "Super"
    );
    assert_eq!(
        root_node.get_child_node(1).unwrap().as_text().unwrap(),
        "Mario Bros"
    );
}
